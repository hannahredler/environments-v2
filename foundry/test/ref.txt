// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.14;

import "forge-std/src/Test.sol";
import "forge-std/src/console2.sol";
import {Mocks} from "@yield-protocol/vault-v2/contracts/test/utils/Mocks.sol";

import {FCashWand, IWitchCustom, INotionalMultiOracle} from "../src/fCashWand.sol";
import {NotionalJoinFactory} from "../src/NotionalJoinFactory.sol";
import {NotionalMultiOracle} from "@yield-protocol/vault-v2/contracts/other/notional/NotionalMultiOracle.sol";
import {FCashMock} from "@yield-protocol/vault-v2/contracts/other/notional/FCashMock.sol";

import {Join} from "@yield-protocol/vault-v2/contracts/Join.sol";
import {DAIMock} from "@yield-protocol/vault-v2/contracts/mocks/DAIMock.sol";
import {ERC20Mock} from "@yield-protocol/vault-v2/contracts/mocks/ERC20Mock.sol";
import {WETH9Mock} from "@yield-protocol/vault-v2/contracts/mocks/WETH9Mock.sol";

import {Cauldron} from "@yield-protocol/vault-v2/contracts/Cauldron.sol";
import {Ladle} from "@yield-protocol/vault-v2/contracts/Ladle.sol";
import {Witch} from "@yield-protocol/vault-v2/contracts/Witch.sol";
import {Timelock} from "@yield-protocol/utils-v2/contracts/utils/Timelock.sol";
//import {AccessControl} from "@yield-protocol/utils-v2/contracts/access/AccessControl.sol";
import {IEmergencyBrake, EmergencyBrake} from "@yield-protocol/utils-v2/contracts/utils/EmergencyBrake.sol";

import "@yield-protocol/vault-interfaces/src/ICauldron.sol";
import '@yield-protocol/vault-interfaces/src/ICauldronGov.sol';
import "@yield-protocol/vault-interfaces/src/IOracle.sol";
import "@yield-protocol/vault-interfaces/src/ILadle.sol";
import '@yield-protocol/vault-interfaces/src/ILadleGov.sol';
import "@yield-protocol/utils-v2/contracts/interfaces/IWETH9.sol";
import '@yield-protocol/utils-v2/contracts/token/IERC20Metadata.sol';

using stdStorage for StdStorage;

interface IFCashWandCustom {
    struct AuctionLimit {
        bytes6 ilkId;
        uint32 duration;
        uint64 initialOffer;
        uint96 line;
        uint24 dust;
        uint8 dec;
    }

    struct DebtLimit {
        bytes6 baseId;
        bytes6 ilkId;
        uint32 ratio;
        uint96 line;
        uint24 dust;
        uint8 dec;
    }
    
    struct NotionalSource {
        bytes6 notionalId;
        bytes6 underlyingId;
        address underlying;
    }

    struct SeriesIlk {
        bytes6 series;
        bytes6[] ilkIds;
    }
}


abstract contract StateDeployWand is Test, IFCashWandCustom {
    using Mocks for *;

    NotionalMultiOracle public notionalMultiOracle;
    NotionalJoinFactory public njoinfactory;
    FCashWand public fcashwand;

    Join public daiJoin; 
    FCashMock public fcash;
    DAIMock public dai;
    WETH9Mock public weth;

    Cauldron public cauldron;
    Ladle public ladle;
    Witch public witch;

    EmergencyBrake public cloak;
    Timelock public timelock;

    address deployer;

    // arbitrary values for testing
    uint40 maturity = 1651743369;   // 4/07/2022 23:09:57 GMT
    uint16 currencyId = 1;         
    uint256 fCashId = 4;

    function setUp() public virtual {

        deployer = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;
        vm.label(deployer, "deployer");

        //... Assets ...
        dai = new DAIMock();
        vm.label(address(dai), "dai token");

        weth = new WETH9Mock();
        vm.label(address(weth), "weth token");
        
        fcash = new FCashMock(ERC20Mock(address(dai)), fCashId);
        vm.label(address(fcash), "fCashMock token");
        
        //... Yield Contracts ...        
        daiJoin = new Join(address(dai));
        vm.label(address(dai), "Dai Join");

        cauldron = new Cauldron();
        vm.label(address(cauldron), "Cauldron");
        
        ladle = new Ladle(ICauldron(address(cauldron)), IWETH9(address(weth)));
        vm.label(address(cauldron), "Ladle");

        witch = new Witch(ICauldron(address(cauldron)), ILadle(address(ladle)));
        vm.label(address(cauldron), "Witch");

        cloak = new EmergencyBrake(deployer, deployer);
        vm.label(address(cloak), "Cloak");

        timelock = new Timelock(deployer, deployer);
        vm.label(address(timelock), "Timelock");

        notionalMultiOracle = new NotionalMultiOracle();
        vm.label(address(notionalMultiOracle), "notionalMultiOracle");

        fcashwand = new FCashWand(ICauldronGov(address(cauldron)), ILadleGov(address(ladle)), IWitchCustom(address(witch)), IEmergencyBrake(address(cloak)), INotionalMultiOracle(address(notionalMultiOracle)));
        vm.label(address(fcashwand), "FCash Wand");

        njoinfactory = new NotionalJoinFactory(address(cloak), address(timelock));
        vm.label(address(njoinfactory), "Njoin Factory");

        vm.startPrank(address(timelock));
        njoinfactory.grantRole(NotionalJoinFactory.deploy.selector, deployer);
        njoinfactory.grantRole(NotionalJoinFactory.getAddress.selector, deployer);
        njoinfactory.grantRole(NotionalJoinFactory.getByteCode.selector, deployer);
        vm.stopPrank();

    }
}

contract StateDeployWandTest is StateDeployWand{
    using Mocks for *;

    function testFCashWand() public {
        console2.log("....");

        // deploy njoin
        address asset = address(fcash);
        address underlying = address(dai); 
        address underlyingJoin = address(daiJoin); 
        uint256 salt = 1234;

        address njoin = njoinfactory.deploy(asset, underlying, underlyingJoin, maturity, currencyId, salt);
        vm.label(njoin, "njoin contract");


        // call wand
        bytes6 assetId = bytes6('01');            //arbitrary 
        address assetAddress= address(fcash);
        address joinAddress = njoin;


        // wand params
        FCashWand.NotionalSource[] memory notionalSources = new FCashWand.NotionalSource[](1);
        notionalSources[0] = FCashWand.NotionalSource({notionalId: bytes6('01'), underlyingId: bytes6('01'), underlying: address(dai)});

        FCashWand.AuctionLimit[] memory auctionLimits = new FCashWand.AuctionLimit[](1);
        auctionLimits[0] = FCashWand.AuctionLimit({
            ilkId: bytes6('01'),
            duration: 10,
            initialOffer: 0.5e18,           // initialOffer <= 1e18, "InitialOffer above 100%"
            line: type(uint96).max,        //  maximum collateral that can be auctioned at the same time
            dust: type(uint16).max,       //  minimum collateral that must be left when buying, unless buying all | uint24
            dec: 8                            
        });


        FCashWand.DebtLimit[] memory debtLimits = new FCashWand.DebtLimit[](1);
        debtLimits[0] = FCashWand.DebtLimit ({
            baseId: bytes6('01'),
            ilkId: bytes6('01'),
            ratio: 1000000,                     // With 6 decimals. 1000000 == 100%
            line: type(uint96).max,             // maximum debt for an underlying and ilk pair  | uint96
            dust: type(uint16).max,             // minimum debt for an underlying and ilk pair  | uint24
            dec: 8                              //  decimals: Multiplying factor (10**dec) for line and dust | uint8             
        });

        FCashWand.SeriesIlk[] memory seriesIlks = new FCashWand.SeriesIlk[](1);

        bytes6[] memory ilkId;
        ilkId[0] = bytes6('01');
        seriesIlks[0] = FCashWand.SeriesIlk ({series: bytes6('01'), ilkIds: ilkId});


        fcashwand.addfCashCollateral(assetId, assetAddress, joinAddress, notionalSources, auctionLimits, debtLimits, seriesIlks);

        //assert
        //   cauldron.ilks(FYUSDC2209, assetId) == true



    }
}